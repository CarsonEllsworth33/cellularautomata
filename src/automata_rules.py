#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Thu Apr  6 07:19:12 2023@author: carsonellsworth"""class Rules():    def __init__(self,matrix):        self.matrix = matrix        self.bounds = len(self.matrix),len(self.matrix[0])        self.future_matrix = [[0 for _ in range(self.bounds[1])] for _ in range(self.bounds[0])]        def rules(self, x, y, neighbor_count):        # RULES ARE CONDITIONS BASED UPON NEIGHBORS IN LOCAL AREA        # Must be implemented by child classes        pass            def nearest_empty_cell(self, x:int, y:int)->(int,int):        nearest_empty = None        try:            if(y+1<self.bounds[1] and self.matrix[x][y+1]==0):                nearest_empty = (x,y+1)                return nearest_empty        except(IndexError):            pass                try:            if(x+1<self.bounds[1] and self.matrix[x+1][y]==0):                nearest_empty = (x+1,y)                return nearest_empty        except(IndexError):            pass                try:            if(y-1>=0 and self.matrix[x][y-1]==0):                nearest_empty = (x,y-1)                return nearest_empty        except(IndexError):            pass                try:            if(x-1>=0 and self.matrix[x-1][y]==0):                nearest_empty = (x-1,y)                return nearest_empty        except(IndexError):            pass        return nearest_empty        def count_neighbors(self, x:int, y:int)->int:        neighbor_count=0        try:            if(y+1<self.bounds[1] and self.matrix[x][y+1]==1):                neighbor_count+=1        except(IndexError):            pass        try:            if(y-1>=0 and self.matrix[x][y-1]==1):                neighbor_count+=1        except(IndexError):            pass        try:            if(x+1<self.bounds[1] and self.matrix[x+1][y]==1):                neighbor_count+=1        except(IndexError):            pass        try:            if(x-1>=0 and self.matrix[x-1][y]==1):                neighbor_count+=1        except(IndexError):            pass                return neighbor_count        def time_step(self):        #here we evaluate the current matrix state and apply the rules to the future matrix state        for i in range(self.bounds[0]):            for j in range(self.bounds[1]):                if(self.matrix[i][j]!=1):                    continue                # first count neighbors                # then apply rules                neighbor_count = self.count_neighbors(i,j)                self.rules(i, j, neighbor_count)                        #There has to be a better way to do this        for i in range(self.bounds[0]):            for j in range(self.bounds[1]):                self.matrix[i][j] = self.future_matrix[i][j]        def _die(self, x:int, y:int):        #SHOULD ONLY BE MODIFYING FUTURE_MATRIX        self.future_matrix[x][y] = 0 #die        def _sustain(self, x:int, y:int):        #SHOULD ONLY BE MODIFYING FUTURE_MATRIX        self.future_matrix[x][y] = self.matrix[x][y]        def _spawn_n(self, x:int, y:int, spawn_count:int):        #SHOULD ONLY BE MODIFYING FUTURE_MATRIX        for _ in range(spawn_count):            self._sustain(x,y)            nearest_empty = self.nearest_empty_cell(x, y)            if(nearest_empty == None):                return            self.future_matrix[nearest_empty[0]][nearest_empty[1]] = 1 #spawn        class Automata(Rules):    def __init__(self,matrix):        super().__init__(matrix)            def rules(self, x, y, neighbor_count):        # NON DIAGONAL AUTOMATA RULES        # EMPTY CELLS CANNOT SPAWN                if(neighbor_count == 0):            # if no neighbors: spawn one            self._spawn_n(x, y, 1)        elif(neighbor_count == 1):            # if one neighbors: spawn two            self._spawn_n(x, y, 2)        elif(neighbor_count == 2):            # if two neighbors: spawn die            self._die(x, y)        elif(neighbor_count == 3):            # if three neighbors: sustain            self._sustain(x, y)        elif(neighbor_count == 4):            # if four neighbors: die            self._die(x, y)            class Automata2(Rules):    def __init__(self,matrix):        super().__init__(matrix)            def rules(self, x, y, neighbor_count):        # NON DIAGONAL AUTOMATA RULES        # EMPTY CELLS CANNOT SPAWN                if(neighbor_count == 0):            # if no neighbors: die            self._die(x, y)        elif(neighbor_count == 1):            # if one neighbors: spawn three            self._spawn_n(x, y, 3)        elif(neighbor_count == 2):            # if two neighbors: sustain            self._sustain(x,y)        elif(neighbor_count == 3):            # if three neighbors: spawn one            self._spawn_n(x, y, 1)        elif(neighbor_count == 4):            # if four neighbors: die            self._die(x, y)    if __name__ == "__main__":    matrix = [        [1,1],        [1,0]        ]    mach = Automata(matrix)    mach.time_step()    print(matrix)    mach.time_step()    print(matrix)    mach.time_step()    print(matrix)    mach.time_step()    print(matrix)                                                                    